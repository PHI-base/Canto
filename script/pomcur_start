#!/usr/bin/perl

use strict;
use warnings;
use Carp;
use File::Basename;
use File::Path;
use File::Copy qw(copy);
use Getopt::Long;

$ENV{POMCUR_CONFIG_LOCAL_SUFFIX} ||= 'deploy';

my $script_name = basename $0;

if (-f $script_name && ! -d "etc") {
  # we're in the scripts directory - go up
  chdir "..";
}

if ($ENV{POMCUR_CONFIG_LOCAL_SUFFIX} eq 'deploy') {
  my $deploy_config_file_name = 'pomcur_deploy.yml';
  my $init_dir = undef;

  GetOptions ("initialise=s" => \$init_dir);

  if ($init_dir) {
    if (-d $init_dir) {
      opendir DIR, $init_dir or die "can't read directory $init_dir: $!\n";
      while (my $entry = readdir DIR) {
        next if($entry =~ /^\.\.?$/);
        closedir DIR;
        die "$0: directory ($init_dir) not empty, won't initialise\n";
      }
      closedir DIR;
    } else {
      if (-e $init_dir) {
        die "$0: $init_dir exists, but isn't an empty directory, won't initialise\n";
      }

      mkpath ($init_dir, {error => \my $err});
      if (@$err) {
        for my $diag (@$err) {
          my ($file, $message) = %$diag;
          warn "error: $message\n";
        }
        exit (1);
      }
    }

    use PomCur::Config;

    my $config = PomCur::Config->new('pomcur.yaml');
    my $track_db_template_file = $config->{track_db_template_file};
    my $dest_file = "$init_dir/track.sqlite3";

    copy ($track_db_template_file, $dest_file);

    open my $deploy_config_fh, '>', $deploy_config_file_name or
      die "can't open $deploy_config_file_name for writing: $!\n";

    print $deploy_config_fh <<"EOF";
"Model::TrackModel":
  schema_class: 'PomCur::TrackDB'
  connect_info:
     - "dbi:SQLite:dbname=$dest_file"
EOF

    close $deploy_config_fh or die "can't close $deploy_config_file_name: $!\n";

    print "Initialisation succesful\n";

    exit (0);
  } else {
    if (!-f $deploy_config_file_name) {
      die "$0: Error - application not initialised

Run with --initialise <some_directory>

<some_directory> must be empty\n";
    }
  }
} else {
  # we're testing
}

require Plack::Runner;
require Plack::Builder;
require Plack::Middleware::ReverseProxy;

require PomCur;

PomCur->setup_engine('PSGI');
my $app = sub { PomCur->run(@_) };

$app = Plack::Middleware::ReverseProxy->wrap($app);

my $runner = Plack::Runner->new;

$runner->parse_options(@ARGV);
$runner->run($app);
